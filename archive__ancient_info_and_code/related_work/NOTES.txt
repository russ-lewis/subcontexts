Toshio Okamoto, et. al.  "A Micro-kernel Architecture for Next Generation Processors"

This is the closest prior art I"ve found to subcontexts.  In this paper, they describe a microkernel architecture based around a single virtual space (SVS) and one level store (OLS).  The key idea of their design is an "rich featured MMU" which has the capability to give access to pages either based on the thread which is currently running *OR* the address of the instruction pointer of the access.  That is, they create two parallel page tables.  One maps threads->access rights to pages; one maps code locations->access rights to pages.

Their goal is similar to mine: to allow applications to call system services through a function call (no kernel intervention), pass them arbitrary arguments using normal function call mechanisms, and to allow the services to access application memory without indirection, marshalling, or kernel services.

In their system, the various elements of the microkernel are all loaded into the same address space.  Pages which are specific to a certain thread (such as stack) are mapped according to the thread; they can be used by any component in the system, when executing that thread.  Pages which are specific to a certain component are mapped according to that component (only the code pages of that component may access those locations), which means that they may be accessed from any thread but only when that thread is running inside that component.

They handle the "entry points" problem by constructing gate pages.  Gate pages are pages that contain nothing but jump instructions into a certain component.  You give the gate pages access to call the server component, and you give the client component access to call the gate pages, but the client component has no rights to call the server component directly.  Thus, the client (theoretically) cannot call to arbitrary locations in the server.

However, there are problems with this.  First, it does not answer the problem of how the server returns to the client: either the server must call back into a well-known location in the client (breaking the function call interface), or it must be allowed to call into arbitrary locations in the client (which is what I choose to do with subcontexts, but it breaks the traditional microkernel security guarantees).  Second, their system is only workable on architectures that have fixed-size instructions.  In the paper, they stated that they planned to simulate this architecture on a 386 or 486 - yet it could not possibly work on that architecture, because the client component could call into any arbitrary location in the gate page, and then run what turns out to be an invalid (or, worse yet, an accidentally valid) instruction!

Moreover, their architecture has serious flaws when one considers how to construct a heirarchal system.  Consider a system where there are 3 components: an application A, a service S1 which A will use for some purpose, and another service S2 which S1 uses to fulfill A's requests.  Now, consider that A wants to ask S1 to do something with one of A's buffers.  A must give S1 access to that buffer.  However, since A knows that S1 might delegate the task to some other component, just giving S1 a pointer to the buffer is insufficient.  Instead, A must either (a) get a list of all of S1's pages, and the pages of all components that S1 might delegate this task to, and give all of those pages access to the buffer (ignoring race conditions where new pages might be added to some components, or relationships might change), or (b) give the buffer to the thread, so that any component running in this thread can access it.  A chooses option (b), the only practical choice, and things work ok.  Now, consider that S1 has a buffer of its own, which it must pass to S2 for some reason.  S1 has the same problem as A: the only practical solution is to give the whole thread access to the buffer.  But now that means that A has access to the buffer, and could corrupt it!

Thus, while Okamoto developed a key idea (you can protect things using the current instruction pointer as a key, not just the current thread), his system is impractical...not to mention that it required custom hardware.  Subcontexts is by far superior because it solves the problems that Okamoto overlooked, and can do so (fairly) efficiently even in a software implementation.

Other problems:
* If you have a multithreaded application, then you will need to give multiple threads access to the same stack (presuming that you want to support, as is conventional with C-family languages, pointers to objects on the stack).  However, this means that an application can corrupt a stack currently in use by a protected service, by having one thread call the service, and then having the other thread muck with the stack.

